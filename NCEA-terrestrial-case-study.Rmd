#NCEA Terrestrial case study

```{r}
library(terra)
library(raster)
library(sf)
library(dplyr)
library(tidyr)
library(purrr)
library(stringr)
library(ggplot2)

bng <- 27700

```

```{r Read-in-2023-2024-monads and clip to England only}
#Read in England Ecosystem survey monad grid references
#Monads surveyed in 2023:
monads_2023 <- st_read("/home/amy.gresham@defra.gov.uk/ncea-species-abundance/Data/HR_Monad.shp")

#select ID and geometry columns
monads_2023_ids <- dplyr::select(monads_2023, monad_id, monad_ref, geometry)
monads_2023_ids$survey_year <- 2023 

#Read in UK region shapefile
GB <- st_read("/home/amy.gresham@defra.gov.uk/ncea-species-abundance/Data/infuse_ctry_2011.shp")
plot(GB$geometry)
England <- GB %>% filter(name == "England")
# Create 2 km buffer around England
England_buffer_2km <- st_buffer(England, dist = 2000)
st_crs(England_buffer_2km) <- 27700

# Ensure CRS matches
monads_2023 <- st_transform(monads_2023, st_crs(England))

#Filter out monads that do not spatially intersect with England
monads_in_england <- st_filter(monads_2023, England, .predicate = st_intersects)

#Plot
plot(England$geometry)
plot(monads_in_england$geometry,add=TRUE)
```


```{r}
#Read in Summarised Botanical Heat Map (1km)

botanic_value_1km <- st_read("/dbfs/mnt/base/unrestricted/source_defra_data_services_platform/dataset_botanical_value_maps/format_SHP_botanical_value_maps/LATEST_botanical_value_maps/Summarised_Botanical_Value_Map_2021_EnglandPolygon.shp")
st_crs(botanic_value_1km)

#Inspect unique strings in value column
unique(botanic_value_1km$valuect)
unique(botanic_value_1km$survycv)

#Step 1: Extract the value of individual monads
#subset monad_ref for monads sampled in 2023
botanic_value_1km_2023_monads <- st_filter(botanic_value_1km, monads_in_england, by = c("monad" = "monad_ref"))

#Step 2: Create numeric column for valuect
botanic_value_1km_2023_monads <- botanic_value_1km_2023_monads %>%
  mutate(valuect_number = case_when(
    valuect == "High" ~ 3,
    valuect == "Moderate" ~ 2,
    valuect == "Low" ~ 1,
    valuect == "no indicators, poor survey coverage" ~ 0,
    TRUE ~ NA_real_  # Handles any unexpected values
  ))

hist(botanic_value_1km_2023_monads$valuect_number)

#Step 3: Make a new value category column that is an average of habitats that are relevant to pollinators
head(botanic_value_1km_2023_monads)
#rstsp = Total number of Rare, Scarce and Threatened (RST) plant species recorded in the monad
#score for each habitat type = number of associated Priority Habitat Positive Indicator (PHPI) species

botanic_value_1km_2023_monads <- botanic_value_1km_2023_monads %>%
  mutate(
    rstsp_numeric = case_when(rstsp == "High" ~ 3, 
                              rstsp == "Moderate" ~ 2,
                              rstsp == "Low" ~ 1,
                              rstsp == "no indicators, poor survey coverage" ~ 0,
                              TRUE ~ NA_real_),
    arable_numeric = case_when(arable == "High" ~ 3,
                               arable == "Moderate" ~ 2,
                               arable == "Low" ~ 1,
                               arable == "no indicators, poor survey coverage" ~ 0,
                               TRUE ~ NA_real_),
    boundry_numeric = case_when(boundry == "High" ~ 3,
                                boundry == "Moderate" ~ 2,
                                boundry == "Low" ~ 1,
                                boundry == "no indicators, poor survey coverage" ~ 0,
                                TRUE ~ NA_real_),
    coastal_numeric = case_when(coastal == "High" ~ 3,
                                coastal == "Moderate" ~ 2,
                                coastal == "Low" ~ 1,
                                coastal == "no indicators, poor survey coverage" ~ 0,
                                TRUE ~ NA_real_),
    fnmrshs_numeric = case_when(fnmrshs == "High" ~ 3,
                                fnmrshs == "Moderate" ~ 2,
                                fnmrshs == "Low" ~ 1,
                                fnmrshs == "no indicators, poor survey coverage" ~ 0,
                                TRUE ~ NA_real_),
    grsslnd_numeric = case_when(grsslnd == "High" ~ 3,
                                grsslnd == "Moderate" ~ 2,
                                grsslnd == "Low" ~ 1,
                                grsslnd == "no indicators, poor survey coverage" ~ 0,
                                TRUE ~ NA_real_),
    heathbg_numeric = case_when(heathbg == "High" ~ 3,
                                heathbg == "Moderate" ~ 2,
                                heathbg == "Low" ~ 1,
                                heathbg == "no indicators, poor survey coverage" ~ 0,
                                TRUE ~ NA_real_),
    montane_numeric = case_when(montane == "High" ~ 3,
                                montane == "Moderate" ~ 2,
                                montane == "Low" ~ 1,
                                montane == "no indicators, poor survey coverage" ~ 0,
                                TRUE ~ NA_real_),
    woodlnd_numeric = case_when(woodlnd == "High" ~ 3,
                                woodlnd == "Moderate" ~ 2,
                                woodlnd == "Low" ~ 1,
                                woodlnd == "no indicators, poor survey coverage" ~ 0,
                                TRUE ~ NA_real_)
    
  ) 

hist(botanic_value_1km_2023_monads$valuect_number)

```

```{r}
#Calculate connectivity of monads based on the botanic quality of the surrounding grid cells
#n grid cells = 8
#overall botanic heat map values = High (3), Moderate (2), Low (1), no indicators, poor survey coverage
#Excluding the monads with poor survey coverage, calculate the average quality value of the 8 neighbouring cells. This will be the connectivity metric.
#See if median performs better?

#1. Extract centroid coordinates for each monad
monads_centroids <- st_centroid(botanic_value_1km_2023_monads)
coords <- st_coordinates(monads_centroids)
botanic_value_1km_2023_monads <- botanic_value_1km_2023_monads %>%
  mutate(x = coords[,1], y = coords[,2])


#2. Define neighbour offsets (+/- 1000m in x and y)
offsets <- expand.grid(dx = c(-1000, 0, 1000), dy = c(-1000, 0, 1000)) %>%
  filter(!(dx == 0 & dy == 0))  # exclude the center cell

#3. Generate neighbor coordinates for all monads
neighbors_df <- botanic_value_1km_2023_monads %>%
  select(monad, x, y) %>%
  crossing(offsets) %>%
  mutate(neighbor_x = x + dx,
         neighbor_y = y + dy)

#4. Prepare full grid with centroid coordinates
grid_centroids <- st_centroid(botanic_value_1km)
grid_coords <- st_coordinates(grid_centroids)
botanic_value_1km <- botanic_value_1km %>%
  mutate(grid_x = grid_coords[,1], grid_y = grid_coords[,2])

#5. Join neighbors to grid
neighbors_with_values <- neighbors_df %>%
  left_join(botanic_value_1km %>% 
              st_drop_geometry() %>% 
select(grid_x, grid_y, valuect),
            by = c("neighbor_x" = "grid_x", "neighbor_y" = "grid_y"))

#6. make numeric value column

neighbors_with_values <- neighbors_with_values %>%
  mutate(
    valuect_numeric = case_when(valuect == "High" ~ 3, 
                              valuect == "Moderate" ~ 2,
                              valuect == "Low" ~ 1,
                              valuect == "no indicators, poor survey coverage" ~ 0,
                              TRUE ~ NA_real_))

#7. Calculate connectivity score
connectivity_scores <- neighbors_with_values %>%
  group_by(monad) %>%
  summarise(connectivity_mean = mean(valuect_numeric[valuect_numeric > 0], na.rm = TRUE))

hist(connectivity_scores$connectivity_mean)

#8. Join back to botanic_value_1km_2023_monads

botanic_value_1km_2023_monads <- botanic_value_1km_2023_monads %>%
  left_join(connectivity_scores, by = "monad")


#9. Export to inspect
st_write(botanic_value_1km_2023_monads, "/tmp/connectivity_monads_botanic_heat.gpkg", delete_dsn = TRUE)
# Then move it to DBFS using system command
file.copy("/tmp/connectivity_monads_botanic_heat.gpkg",
          "/dbfs/mnt/lab/unrestricted/amy.gresham@defra.gov.uk/connectivity_monads_botanic_heat.gpkg")

st_write(botanic_value_1km_2023_monads, "/home/amy.gresham@defra.gov.uk/ncea-species-abundance/Output/connectivity_monads_botanic_heat.shp", append=FALSE)

```

```{r Assign common names to vascular plants and join to monads}

vascular_plants_2023 <- read.csv("/home/amy.gresham@defra.gov.uk/ncea-species-abundance/Data/HR_Veg_vascular_plants_57.csv")

#Read in name list from Sweet

plant_names <- read.csv("/home/amy.gresham@defra.gov.uk/ncea-species-abundance/Data/Sweet major plant list  TVK.csv")

#Get NBN accession number, common name and scientific name

plant_names <- plant_names %>% 
  dplyr::rename(scientific_name = RECOMMENDED_SCIENTIFIC_NAME,
                nbn_key = NBN_TAXON_VERSION_KEY)

# Perform the left join
vascular_plants_2023_names <- merge(
  x = vascular_plants_2023,
  y = plant_names,
  by.x = "Species",
  by.y = "nbn_key",
  all.x = TRUE
)

#Create genus, species and common_name columns
vascular_plants_2023_names <- vascular_plants_2023_names %>%
  mutate(
    genus = word(scientific_name, 1),
    species = if_else(
      str_detect(scientific_name, "\\b\\w+\\s+\\w+"),
      word(scientific_name, 2),
      NA_character_
    ),
    common_name = str_extract(scientific_name, "(?<=\\().+?(?=\\))")
  )


#Read in vegetation plot names

veg_plots_2023 <- read.csv("/home/amy.gresham@defra.gov.uk/ncea-species-abundance/Data/HR_Vegetation_plot_9.csv")

# Join veg_plots_2023 to vascular_plants_2023_names by Veg.plot.ID
vascular_plants_2023_monads <- left_join(
  vascular_plants_2023_names,
  veg_plots_2023 %>% dplyr::select(Veg.plot.ID, Monad.ID),
  by = "Veg.plot.ID"
)

# Join monad_ref from veg_monads_2023 using Monad.ID and monad_id
vascular_plants_2023_monads_ref <- left_join(
  vascular_plants_2023_monads,
  monads_in_england %>% dplyr::select(monad_id, monad_ref),
  by = c("Monad.ID" = "monad_id")
)

#Create full binomial names from genus and species
vascular_plants_2023_monads_ref <- vascular_plants_2023_monads_ref %>%
  mutate(binomial = ifelse(is.na(species), genus, paste(genus, species)))

# Convert scientific_name column to character
vascular_names <- as.character(vascular_plants_2023_monads_ref$scientific_name)
print(unique(sort(vascular_names)))

#Modify some names so that they match those in the nectar dataset
vascular_plants_2023_monads_ref <- vascular_plants_2023_monads_ref %>%
  mutate(
    scientific_name = str_replace(as.character(.data[["scientific_name"]]), "^Brassica$", "Brassica spp"),
    binomial = str_replace(as.character(.data[["binomial"]]), "^Brassica$", "Brassica spp")
  )

#Check the most common plants in the dataset by occurrence and by percentage cover

species_summary <- vascular_plants_2023_monads_ref %>%
  filter(!is.na(monad_ref)) %>%
  group_by(binomial) %>%
  summarise(
    monad_count = n_distinct(monad_ref),         # Number of unique monads
    total_cover = sum(Cover.., na.rm = TRUE)     # Total percentage cover
  ) %>%
  arrange(desc(monad_count), desc(total_cover))  # Sort by prevalence

#After about 100 plants, the total cover starts to drop off
top_plants_cover <- species_summary %>%
  slice_max(order_by = total_cover, n = 100)

top_plants_presence <- species_summary %>%
  slice_max(order_by = monad_count, n = 100)

#Most plants in one list also occur in the other, but lower down the lists there are different plants
#I think let's go for the most commonly occurring plants across the monads (presence rather than cover)
#Now see if you can match these most common plants with the nectar production datasets


```

```{r}
#Resource production of flowers for pollinators

#1. We can calculate nectar and pollen production in monads from the vascular plant survey data using existing datasets to get a relative measure of food resource availability for pollinators (see datasets saved in Zotero)

#2. We can assess landscape-scale pollen and nectar production by looking at land cover, e.g. -	Historical nectar assessment reveals the fall and rise of floral resources in Britain | Nature: https://www.nature.com/articles/nature16532#Sec11

#Read in datasets from these three papers which have both measured nectar production in ug per flower per 24 hours

#1. Historical nectar assessment reveals the fall and rise of floral resources in Britain | Nature: https://www.nature.com/articles/nature16532#Sec11
#Nectar measure: sugar content in ug per flower per day

nectar1 <- read.csv("/home/amy.gresham@defra.gov.uk/ncea-species-abundance/Data/41586_2016_BFnature16532_MOESM67_ESM.csv")
colnames(nectar1) <- as.character(nectar1[1, ]) #Replace column names with values from row 2
nectar1<- nectar1[-c(1:2), ] #Remove row 1 and 2
nectar1 <- nectar1 %>% dplyr::select(c("latin name","nectar sugar content in µg/flower/day"))
#Remove NAs
nectar1 <- na.omit(nectar1)
head(nectar1)

#2. -	Quantifying nectar production by flowering plants in urban and rural landscapes - Tew - 2021 - Journal of Ecology - Wiley Online Library https://besjournals.onlinelibrary.wiley.com/doi/10.1111/1365-2745.13598
#Nectar measure: sugar content in ug per floral unit per day
nectar2 <- read.csv("/home/amy.gresham@defra.gov.uk/ncea-species-abundance/Data/Nectar_sugar_per_taxon.csv")
nectar2 <- nectar2 %>% select(c("taxon","sugar_per_floral_unit_ug"))
nectar2 <- nectar2 %>%
  mutate(taxon = str_replace_all(taxon, "\\bagg\\b", "agg."))
#Replace "Taraxacum agg" with "Taraxacum agg."
head(nectar2)

#3. -	A dataset of nectar sugar production for flowering plants found in urban green spaces - Tew - 2023 - Ecological Solutions and Evidence - Wiley Online Library: https://besjournals.onlinelibrary.wiley.com/doi/full/10.1002/2688-8319.12248
#Nectar measure: sugar production in ug per flower per day
nectar3 <- read.csv("/home/amy.gresham@defra.gov.uk/ncea-species-abundance/Data/Nectar_data_dryad.csv")
nectar3 <- nectar3 %>% select(c("Taxon","Nectar_mass_mean"))
head(nectar3)

# Combine all nectar taxon names
nectar_taxa <- unique(c(nectar1$taxon, nectar2$taxon, nectar3$taxon))

# Convert to character to avoid factor issues
nectar_taxa <- as.character(nectar_taxa)
print(sort(nectar_taxa))

# Find matches using partial string matching
matched_taxa <- nectar_taxa[sapply(nectar_taxa, function(x) any(grepl(x, vascular_names, ignore.case = TRUE)))]
print(sort(matched_taxa))

#See how many of these taxa occur in the EES vascular plant dataset in the top 100 most frequently occurring species across monads
matched_in_top_presence <- top_plants_presence %>%
  filter(binomial %in% matched_taxa)

matched_in_top_cover <- top_plants_cover %>%
  filter(binomial %in% matched_taxa)

#These plant taxa, top of the vascular plant dataset in occurrence and cover, that also match with the nectar datasets, will be the measure of nectar availability in the monads

```

```{r}
#Identify which taxa from these three datasets are present in the EES vascular plant data
# Standardize column names for matching
names(nectar1)[1] <- "taxon"
names(nectar2)[1] <- "taxon"
names(nectar3)[1] <- "taxon"

#See how many taxa are replicated across these datasets
# Step 1: Extract unique taxa from each dataset
taxa1 <- unique(nectar1$taxon)
taxa2 <- unique(nectar2$taxon)
taxa3 <- unique(nectar3$taxon)

# Step 2: Combine all taxa into one vector
all_taxa <- c(taxa1, taxa2, taxa3)

# Step 3: Count duplicates
duplicated_taxa <- all_taxa[duplicated(all_taxa)]
print(sort(duplicated_taxa))
#n duplicates = 187, will need to either take average nectar production measurements from across the datasets, or decide on a dominant dataset.

#Take the average across the datasets for these 187 taxa, then inspect the standard deviations on a plot (boxplot?)
# Step 1: Combine all nectar datasets into one

names(nectar1)[2] <- "nectar_ug_per_flower_per_day"
names(nectar2)[2] <- "nectar_ug_per_flower_per_day"
names(nectar3)[2] <- "nectar_ug_per_flower_per_day"

# Convert nectar values to numeric in all three datasets
nectar1$nectar_ug_per_flower_per_day <- as.numeric(nectar1$nectar_ug_per_flower_per_day)
nectar2$nectar_ug_per_flower_per_day <- as.numeric(nectar2$nectar_ug_per_flower_per_day)
nectar3$nectar_ug_per_flower_per_day <- as.numeric(nectar3$nectar_ug_per_flower_per_day)

# Now safely combine them
nectar_all <- rbind(nectar1, nectar2, nectar3)

# Find exact duplicate rows across the combined dataset
duplicates_across_sources <- nectar_all %>%
  duplicated() %>%
  which()

# View those duplicated rows
nectar_all[duplicates_across_sources, ]

#There are some duplicates, perhaps because of something I've done, or perhaps the papers used information from the same sources in their studies
# Step 2: Filter for duplicated rows
nectar_all_unique <- nectar_all %>%
  distinct()

# Step 3: Calculate mean and standard deviation per taxon
nectar_stats <- nectar_repeated %>%
  group_by(taxon) %>%
  summarise(
    mean_sugar = mean(nectar_sugar, na.rm = TRUE),
    sd_sugar = sd(nectar_sugar, na.rm = TRUE),
    n = n()
  ) %>%
  arrange(desc(mean_sugar))

# Step 4: Visualize variation using boxplot
ggplot(nectar_repeated, aes(x = reorder(taxon, nectar_sugar), y = nectar_sugar)) +
  geom_boxplot(fill = "lightblue", color = "darkblue") +
  coord_flip() +
  labs(
    title = "Variation in Nectar Sugar Content for Repeated Taxa",
    x = "Taxon",
    y = "Nectar Sugar Content (µg/flower/day)"
  ) +
  theme_minimal()



```


```{r}
# Diversity and evenness of plants

#Sites with greater plant diversity and cover will support a greater abundance of pollinators

# Step 1: Create full binomial names from genus and species
vascular_plants_2023_monads_ref <- vascular_plants_2023_monads_ref %>%
  mutate(binomial = ifelse(is.na(species), genus, paste(genus, species)))

#Get taxonomic richness per monad at the genus level

# plant_names <- unique(vascular_plants_2023_monads_ref$binomial)
# #Export plant names list for classification
# plant_names_to_export <- vascular_plants_2023_monads_ref %>% dplyr::select(c(genus,species,binomial,common_name,Cover..))
# #Export
# write.csv(plant_names_to_export, "/home/amy.gresham@defra.gov.uk/ncea-species-abundance/Output/plant_names_veg_survey_2023.csv")

```




```{r}
#Get sward height - indicator of habitat quality

#The four sward columns are the modal sward height from each quarter of the veg plot.
#Exert from EES manual: "Record modal sward height using a ruler in each quarter  of the plot. This is the height at which most of the  vegetation sits. Ignoring tall stalks, place a hand or card lightly on the vegetation at a level below which about 80% of it is estimated (by eye) to be growing. Read this value off a ruler and record it to the nearest cm. Four values will provide a measure of heterogeneity within the plot."

sward <- read.csv("/home/amy.gresham@defra.gov.uk/ncea-species-abundance/Data/HR_Vegetation_plot_9.csv")

sward <- sward %>% dplyr::select (c(Monad.reference,Veg.plot.ID,Veg.Plot.reference,Sward.height.1..cm.,Sward.height.2..cm.,Sward.height.3..cm.,Sward.height.4..cm.))

# Rename columns
sward_clean <- sward %>%
  dplyr::rename(
    Monad = Monad.reference,
    PlotID = Veg.plot.ID,
    PlotRef = Veg.Plot.reference,
    Height1 = Sward.height.1..cm.,
    Height2 = Sward.height.2..cm.,
    Height3 = Sward.height.3..cm.,
    Height4 = Sward.height.4..cm.
  )

# Reshape the data from wide to long format
sward_long <- sward_clean %>%
  pivot_longer(cols = starts_with("Height"),
               names_to = "Height_Measurement",
               values_to = "Height")

# Group by Monad and calculate summary statistics
sward_summary <- sward_long %>%
  group_by(Monad) %>%
  dplyr::summarise(
    Mean_Height = mean(Height, na.rm = TRUE),
    SD_Height = sd(Height, na.rm = TRUE),
    SE_Height = SD_Height / sqrt(n())
  )

#Reorder Monad factor by Mean_Height
sward_summary <- sward_summary %>%
  mutate(Monad = factor(Monad, levels = Monad[order(Mean_Height)]))


ggplot(sward_summary, aes(x = Monad, y = Mean_Height)) +
  geom_bar(stat = "identity", fill = "skyblue") +
  geom_errorbar(aes(ymin = Mean_Height - SE_Height,
                    ymax = Mean_Height + SE_Height),
                width = 0.2) +
  theme_minimal() +
  labs(title = "Mean Sward Height per Monad",
       x = "Monad",
       y = "Mean Height (± SE)") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```


```{r}
#Read in stitched Living England 2022-2023
LE <- raster( "/dbfs/mnt/lab/unrestricted/amy.gresham@defra.gov.uk/Living_England_2022_2023_whole_raster.tif")
crs(LE) <- 27700 # british national grid

```

```{r}
#Quality control checking of vascular plant data

#Identify any veg plots that have been surveyed more than once
repeat_surveys <- veg_plots_2023 %>%
  group_by(Veg.plot.ID) %>%
  summarise(n_surveys = n_distinct(Survey.start)) %>%
  filter(n_surveys > 1)
#No duplicates identified - each veg plot surveyed only once

#List the Veg.plot.IDs in vascular_plants_2023_names that don’t exist in veg_plots_2023.
mismatched_plan_df_ids <-anti_join(vascular_plants_2023_names, veg_plots_2023, by = "Veg.plot.ID") %>%
  distinct(Veg.plot.ID)
#24 veg plots apprear in vascular_plant_2023_names that do not appear in the veg plot dataset
mismatched_veg_plot_ids <- anti_join(veg_plots_2023, vascular_plants_2023_names, by = "Veg.plot.ID") %>%
  distinct(Veg.plot.ID)
#35 veg plot ids appear in veg plot dataset that do not appear in the vascular plant dataset

#Get the number of unique veg plots for every monad in the veg plot dataset
veg_plot_counts_vegplots2023 <- veg_plots_2023 %>%
  group_by(Monad.reference, Monad.ID) %>%
  summarise(
    n_veg_plots = n_distinct(Veg.plot.ID),
    .groups = "drop"
  ) %>%
  arrange(Monad.reference)

#Inspect percentage cover of veg plots in vascular plant dataset - do they all add up to 100?
# Summarise cover per plot
cover_check <- vascular_plants_2023 %>%
  group_by(Veg.plot.ID) %>%
  summarise(
    total_cover = sum(Cover.., na.rm = TRUE),
    n_species = n(),
    .groups = "drop"
  ) %>%
  filter(total_cover > 0) %>%
  arrange(total_cover)


```
